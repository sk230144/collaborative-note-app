/**
 * @file Firestore Security Rules for Collaborative Note-Taking App
 *
 * @core_philosophy This ruleset enforces a strict user-ownership model for notes and their versions,
 * while also enabling collaborative access through a denormalized 'members' map on each note document.
 * Only the owner or members with appropriate roles can read or modify notes. Versions inherit
 * access control from their parent note.
 *
 * @data_structure Data is nested under /users/{userId}/notes/{noteId} for individual user notes.
 * Versions are stored as subcollections under each note: /users/{userId}/notes/{noteId}/versions/{versionId}.
 *
 * @key_security_decisions
 *   - User listing is disallowed to protect user privacy.
 *   - Notes require explicit ownership, enforced through path-based access control.
 *   - Collaborative access to notes is managed through the 'members' map, which stores user roles.
 *   - Data validation is limited to authorization-critical fields to facilitate rapid prototyping.
 *
 * @denormalization_for_authorization The 'members' map on each note denormalizes user roles,
 * allowing for efficient authorization checks without requiring extra `get()` calls. This map
 * should store user IDs as keys and roles (e.g., 'owner', 'editor', 'viewer') as values.
 *
 * @structural_segregation Private notes are stored under /users/{userId}/notes/{noteId},
 * ensuring that only the owner and authorized members can access them. Public notes could
 * potentially be stored in a separate top-level collection, but this is not currently
 * implemented in the provided data structure.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing document, based on the userId path parameter.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the authenticated user has the specified role in the 'members' map of the note.
     * @param role The role to check for (e.g., 'owner', 'editor', 'viewer').
     */
    function hasRole(role) {
        return isSignedIn() && resource.data.members[request.auth.uid] == role;
    }

    /**
     * @description Checks if the authenticated user has the specified role in the 'members' map of the request data.
     * @param role The role to check for (e.g., 'owner', 'editor', 'viewer').
     */
    function hasRoleInRequest(role) {
        return isSignedIn() && request.resource.data.members[request.auth.uid] == role;
    }

    /**
     * @description Rules for notes owned by a user.
     * @path /users/{userId}/notes/{noteId}
     * @allow (create) User A creates a note under /users/A/notes/note1 with request.auth.uid == "A".
     * @allow (get) User A gets a note under /users/A/notes/note1.
     * @allow (update) User A updates a note under /users/A/notes/note1.
     * @allow (delete) User A deletes a note under /users/A/notes/note1.
     * @deny (create) User B tries to create a note under /users/A/notes/note1.
     * @deny (update) User B tries to update a note under /users/A/notes/note1.
     * @deny (delete) User B tries to delete a note under /users/A/notes/note1.
     * @principle Enforces document ownership for writes and allows owner reads.
     */
    match /users/{userId}/notes/{noteId} {
      // Read Rules:
      allow get: if isOwner(userId) || hasRole('viewer') || hasRole('editor') || hasRole('owner');
      allow list: if isOwner(userId);

      // Write Rules:
      allow create: if isOwner(userId) && request.resource.data.id == noteId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for versions of notes.
     * @path /users/{userId}/notes/{noteId}/versions/{versionId}
     * @allow (create) User A creates a version under /users/A/notes/note1/versions/version1.
     * @allow (get) User A gets a version under /users/A/notes/note1/versions/version1.
     * @allow (update) User A updates a version under /users/A/notes/note1/versions/version1.
     * @allow (delete) User A deletes a version under /users/A/notes/note1/versions/version1.
     * @deny (create) User B tries to create a version under /users/A/notes/note1/versions/version1.
     * @deny (update) User B tries to update a version under /users/A/notes/note1/versions/version1.
     * @deny (delete) User B tries to delete a version under /users/A/notes/note1/versions/version1.
     * @principle Enforces document ownership and inherits access control from the parent note.
     */
    match /users/{userId}/notes/{noteId}/versions/{versionId} {
      // Read Rules:
      allow get: if isOwner(userId) || hasRole('../../../notes/$(noteId)', 'viewer') || hasRole('../../../notes/$(noteId)', 'editor') || hasRole('../../../notes/$(noteId)', 'owner');
      allow list: if isOwner(userId);

      // Write Rules:
      allow create: if isOwner(userId) && request.resource.data.noteId == noteId;
      allow update: if isExistingOwner(userId) && request.resource.data.noteId == resource.data.noteId;
      allow delete: if isExistingOwner(userId);
    }
  }
}
